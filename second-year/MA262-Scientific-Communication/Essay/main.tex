% vim: set foldmethod=marker foldlevel=0:

% TODO: Before submitting:
% - Fully anonymise essay
% - Should be approximately 10-12 pages of content (not including contents,
%   bibliography, etc.)
% - Maximum of 15 pages
% - Remove unneeded packages from preamble

\documentclass[a4paper, 11pt]{article}
\usepackage[UKenglish]{babel}

\usepackage{amsmath, amssymb, amsgen}
\usepackage{gensymb}
\usepackage{mathtools}
\usepackage{csquotes}
\usepackage{cancel}

\usepackage{amsthm}
\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newtheorem{example}{Example}[section]

\usepackage[shortlabels]{enumitem}
% \setlist[enumerate]{topsep=0pt}
% \setlist[itemize]{topsep=0pt}

\usepackage[
    backend=biber,
    % citestyle=,
    % bibstyle=,
    style=alphabetic,
    sorting=nty,
]{biblatex}
\addbibresource{main.bib}

\renewcommand\multicitedelim{\addsemicolon\space}

% Name-related code used to display initials instead of middle names in
% bibliography, while maintaining maximum specificity in .bib file
% Taken from https://tex.stackexchange.com/a/188350
\renewcommand*{\mkbibnamegiven}[1]{\edef\firstname{#1}\expandafter\first{\firstname}}

\def\bibnamedelima{ }%
\def\bibnamedelimb{ }%

\makeatletter
\def\@empty{}
\def\first#1{\expandafter\@first#1 \@nil}
\def\@first#1 #2\@nil{#1\addspace%
    \if\relax\detokenize{#2}\relax\else\@initials#2\@nil\fi}
\def\initials#1{\expandafter\@initials#1 \@nil}
\def\@initials#1 #2\@nil{%
    \initial{#1}%
    \def\NextName{#2}%
    \ifx\@empty\NextName\relax%
    \else\bibinitdelim\@initials#2\@nil\fi}
\def\initial#1{\expandafter\@initial#1\@nil}
\def\@initial#1#2\@nil{#1\bibinitperiod}
\makeatother

\usepackage[hidelinks]{hyperref}

\usepackage{minted}
\setminted{
	linenos,
	breaklines,
	fontsize=\footnotesize,
	encoding=utf8,
	style=catppuccin-latte, % Style provided by https://github.com/catppuccin/python
}

\usepackage[quiet]{fontspec}
\setmonofont[Scale=MatchLowercase]{Hack}

\usepackage{fancyhdr}
\pagestyle{fancy}
% TODO: Decide what to do with these
\fancyhead[L]{}
\fancyhead[C]{}
\fancyhead[R]{}

% \usepackage{graphicx}
% \graphicspath{ {./imgs/} }

\newcommand\acong{\equiv_\alpha}
\newcommand\bcon{\mathrel{\triangleright_{1\beta}}}
\newcommand\bred{\mathrel{\triangleright_\beta}}
\newcommand\FV{\operatorname{FV}}
\newcommand\doublelambda{\lambda\mkern-7.5mu\lambda}

% TODO: Declare some reduction relations like $\triangleright_\beta$ with \mathrel or similar to get consistent spacing

\title{\vspace*{-5em} Numbers in the Lambda-Calculus}
\author{}
\date{}

\begin{document}

\maketitle

% \setlength{\parindent}{0em}
% \setlength{\parskip}{1em}

% \pagenumbering{roman}
% \tableofcontents
% \newpage
% \pagenumbering{arabic}

% Plan {{{

% \section{Introduction}

% Recall set theoretic definition of natural numbers so we can draw parallels to them later, and to establish theme of abstract, fundamental definitions. Define the syntax of the lambda calculus, possibly with examples like $\overline \lambda x . x + 3$ but being careful not to conflate the standard lambda syntax\footnote{It is easy to give an example like the one above with the bare $\lambda$, but this can create confusion later when the rules become strict and readers might wonder why we were allowed addition and natural numbers previously.}.

% Motivation using Dana Scott's $D_\infty$~\parencites[\S16]{hindley-seldin-2008-lambda-calculus-and-combinators}[\S\S18--20]{barendregt-1981-lambda-calculus}.

% \section{Abstraction and application}

% Discuss the notions of abstraction and application. It is likely necessary to talk about free and bound variables and discuss the basics of well-formed formulas. Give examples. Also talk about currying conceptually as well as a syntactic shorthand. Possibly include humorous aside from Hindley about `sch\"onfinkeling'~\parencite[p.~3]{hindley-seldin-2008-lambda-calculus-and-combinators}.

% \section{Reduction and conversion}

% Discuss $\alpha$ and $\beta$ reduction. Possibly also $\eta$ reduction. Also mention the Church--Rosser theorem~\parencite[p.~14]{hindley-seldin-2008-lambda-calculus-and-combinators}, which says that two terms are convertible if both reduce to a common term. I don't think it would be feasible to prove this theorem~\parencite[pp.~282--289]{hindley-seldin-2008-lambda-calculus-and-combinators}, but it would be good to mention. % chktex 8

% \subsection{Ideas}

% We need to define the syntax and semantics. We should talk about currying and its $\lambda x y . \cdots$ shorthand. We should define Church numerals, addition, subtraction (how?), and multiplication (does this need recursion?). Maybe conclude with a method to generate the $n$th Fibonacci number. A function would require introducing recursion, which is too much to fit in one essay.

% \section{Numbers}

% This is the climax of the essay. Define Church numerals~\parencites[p.~347]{church-1936-unsolvable-problem-number-theory}[p.~28]{church-1965-calculi-lambda-conversion}[p.~136]{barendregt-1981-lambda-calculus} and their successor function. Possibly also their predecessor function if it's not too complicated (but I suspect it is). Define the first few Fibonacci numbers and point out the pattern for generating more.

% Alternatively, use the Church--Rosser Theorem to prove that addition of Church numerals commutes. % chktex 8

% \section{Further reading}

% Mention recursive functions, fixed-point combinators, Curry's paradoxical combinator~\parencite[\S6.1]{barendregt-1981-lambda-calculus} (often called the Y~combinator), and allude to a recursive definition of the Fibonacci numbers. Also mention \citetitle{turing-1937-computability-and-lambda-definability}, which shows that the $\lambda$-calculus is equivalent to a Turing machine. Also mention efforts to formalise mathematics in the language of $\lambda$-calculus and combinatory logic, \`a~la Zermelo--Fraenkel set theory. % chktex 8

% }}}

\section{Introduction}\label{sec:introduction}

The Zermelo--Fraenkel system of axioms formalises the foundations of mathematics using the language of sets. It is natural to ask which other languages we could use. What about functions? The Zermelo--Fraenkel system defines functions as sets of ordered pairs~\parencite[\S\S2.1--2.2]{ciesielski-1997-set-theory} but we can't do that in a system where we don't have sets, so we need a more broad definition of functions. % chktex 8

% TODO: Talk about history

\section{Syntax}\label{sec:syntax}

In this new lambda calculus, we care primarily about functions, but the common way of writing functions becomes cumbersome for higher-order functions (functions from functions to functions).

% TODO: Is $S$ actually an operator?
% Properly explain this idea of only having functions? Maybe put this in the history section?
% Why exactly can't we do it in ZFC? Can we do it in ZFC?

Let's say we want to define a function $S$ which takes three functions $x, y, z$ as input, and returns the function $(x(z)) (y(z))$. Take a moment to parse that: $x, y, z$ are all functions; $x(z)$ is a function, call it $f$; $y(z)$ is a function, call it $g$, and then $S$ is $f(g)$, another function\footnote{We could write this with composition as $(x \circ z) \circ (y \circ z)$ but we want to stick the $\lambda$-calculus-style notation for consistency.}.

This is called the $\mathbf{S}$ combinator and we will see its uses later.

To describe $S$ in full generality in the ZFC system is actually impossible because we need to define a domain. We could say \[
S : F \times F \times F \to F, \qquad (x, y, z) \mapsto (x(z)) (y(z))
\] where $F$ denotes some space of functions $F \to F$. This recursive definition of $F$ is not allowed in ZFC\@. % TODO: Citation needed

In the lambda calculus, we write this simply as \[
\lambda x y z . xz(yz)
\]

More formally, $\lambda$-calculus consists of $\lambda$-terms, defined in the following recursive way \parencite[p.~3]{hindley-seldin-2008-lambda-calculus-and-combinators}:
\begin{enumerate}[(1)]
\item All variables (labelled $a, b, \dotsc, z, a_1, b_1, \dotsc$) are $\lambda$-terms, called \textit{atoms}.
\item If $M$ and $N$ are any two $\lambda$-terms then $(MN)$ is a $\lambda$-term. This is called \textit{application}.
\item If $M$ is any $\lambda$-term and $x$ is any variable then $(\lambda x . M)$ is a $\lambda$-term. This is called \textit{abstraction}.
\end{enumerate}

\section{Conversion and reduction}\label{sec:conversion-and-reduction}

Given $\lambda$-terms $M$ and $N$ and a variable $x$, we write $M [x := N]$ to mean a new $\lambda$-term which is $M$ with all occurrences of $x$ replaced with $N$ \parencite[p.~27]{barendregt-1981-lambda-calculus}\footnote{Other notations include $\left. S_N^{\,x} M \right\vert$ \parencite[p.~9]{church-1965-calculi-lambda-conversion} and $[N / x] M$ \parencites[p.~7]{hindley-seldin-2008-lambda-calculus-and-combinators}[\S\textbf{2}C2]{curry-feys-1958-combinatory-logic-volume-1}.}. For example, \[ (\lambda x y . z x z) \l[ z := (\lambda a . a) \r] \rightarrow (\lambda x y . (\lambda a . a) x (\lambda a . a)). \]

\begin{defn}[$\alpha$-conversion]\label{def:alpha-conversion}
Let a $\lambda$-term $P$ contain an occurrence of $\lambda x . M$ and let $y \notin \FV(M)$. The act of replacing the $\lambda x . M$ with $\lambda y . M [x := y]$ is called \textit{$\alpha$-conversion}.

If a $\lambda$-term $Q$ can be reached by a finite (possibly empty) sequence of $\alpha$-conversions, we say that \textit{$P$ $\alpha$-converts to $Q$} and write $P \acong Q$ \parencite[p.~9]{hindley-seldin-2008-lambda-calculus-and-combinators}.
\end{defn}

\begin{defn}[$\beta$-reduction]\label{def:beta-reduction}
Any term of the form $(\lambda x . M) N$ is called a \textit{$\beta$-redex} and the corresponding term $M [x := N]$ is called its \textit{contractum}.

If a $\lambda$-term $P$ contains an occurrence of $(\lambda x . M) N$ then we can replace that occurrence by $M [x := N]$. We can call the result $P'$ and then we say that \textit{$P$ $\beta$-contracts to $P'$}, and we write $P \bcon P'$.

If a $\lambda$-term $Q$ can be reached by a finite (possibly empty) sequence of $\beta$-contractions, we say that \textit{$P$ $\beta$-reduces to $Q$} and write $P \bred Q$ \parencite[pp.~11--12]{hindley-seldin-2008-lambda-calculus-and-combinators}.
\end{defn}

\begin{defn}[$\beta$-normal form]\label{def:beta-normal-form}
A $\lambda$-term $Q$ which contains no $\beta$-redexes is said to be in \textit{$\beta$-normal form}, sometimes written \textit{$\beta$-nf}. If $P \bred Q$ then $Q$ is called a \textit{$\beta$-normal form of $P$} \parencites[p.~12]{hindley-seldin-2008-lambda-calculus-and-combinators}[p.~34]{barendregt-1981-lambda-calculus}.
\end{defn}

\begin{example}[$\beta$-reduction]\label{ex:beta-reduction}
Let $N$ be an arbitrary $\lambda$-term.
\begin{enumerate}[(1)]
\item $(\lambda x . x) N \bcon N$

\item $(\lambda x . y) N \bcon y$

\item $(\lambda xy . y) N \bcon \lambda y . y$

\item $\begin{aligned}[t]
\big( \lambda xy . x (\lambda z . xzy) \big) (\lambda ab . baa)
    &\bcon \lambda y . (\lambda ab . baa) (\lambda z . (\lambda ab . baa) zy) \\
    &\bcon \lambda y . (\lambda ab . baa) (\lambda z . (\lambda b . bzz) y) \\
    &\bcon \lambda y . (\lambda ab . baa) (\lambda z . yzz) \\
    &\bcon \lambda y . \big( \lambda b . b (\lambda z . yzz) (\lambda z . yzz) \big) \\
    &\equiv \lambda yb . b (\lambda z . yzz) (\lambda z . yzz)
\end{aligned}$

% \item $(\lambda xy . y) N \bred \lambda y . y$

\item $\begin{aligned}[t]
\big( \lambda xyz . x (z y x) \big) (\lambda ab . b b a)
    &\bcon \lambda yz . (\lambda ab . b b a) \big( z y (\lambda ab . b b a) \big) \\
    &\bcon \lambda yz . \Big( \lambda b . b b \big( z y (\lambda cd . d d c) \big) \Big) \\
    &\equiv \lambda yzb . b b \big( z y (\lambda cd . d d c) \big)
\end{aligned}$

This example uses the $\alpha$-conversion convention to rename $a$ to $c$ and $b$ to $d$ after the second $\beta$-contraction. Without this renaming, we would get confusing (but technically valid) variable bindings: \[
\lambda yzb . b b \big( z y (\lambda ab . b b a) \big)
\] In this case, the $b$ inside the innermost brackets is completely unrelated to the $b$ outside, so giving them different names makes the expression easier to understand.

\item\label{ex:beta-reduction:Omega} $\begin{aligned}[t]
(\lambda x . xx) (\lambda x . xx)
    &\bcon (\lambda x . xx) (\lambda x . xx) \\
    &\bcon (\lambda x . xx) (\lambda x . xx) \\
    &\bcon \dotsb
\end{aligned}$

This example shows that the $\beta$-contraction process doesn't always simplify. This term is called $\Omega$ or $\mathbf{M}$. Since $\Omega$ contains $\beta$-redexes and $\Omega \bcon \Omega$, we see that $\Omega$ is an example of a $\lambda$-term with no $\beta$-normal form. But $\Omega$ is `minimal' in the sense that it cannot be reduced to any different term \parencite[p.~13]{hindley-seldin-2008-lambda-calculus-and-combinators}.

\item $\begin{aligned}[t]
(\lambda x . xxy) (\lambda x . xxy)
    &\bcon (\lambda x . xxy) (\lambda x . xxy) y \\
    &\bcon (\lambda x . xxy) (\lambda x . xxy) yy \\
    &\bcon \dotsb
\end{aligned}$

In this example, the $\beta$-contraction process actually makes the expression more `complicated' (in the sense of containing more terms). The initial term $(\lambda x . xxy) (\lambda x . xxy)$ is called $\mathbf{L}$, and it has no $\beta$-normal form.

\item Let $P \equiv (\lambda a . b) \mathbf{L}$. Then $P$ can be reduced in multiple ways, by $\beta$-contracting either $(\lambda a . b)$ or $\mathbf{L}$:
\begin{enumerate}[(i)]
    \item $\begin{aligned}[t]
    P &\equiv (\lambda a . b) \mathbf{L} \\
        &\bcon b [a := \mathbf{L}] \\
        &\equiv b
    \end{aligned}$

    \item $\begin{aligned}[t]
    P &\equiv (\lambda a . b) \mathbf{L} \\
        &\bcon (\lambda a . b) \mathbf{L} y \\
        &\bcon (\lambda a . b) \mathbf{L} yy \\
        &\bcon \dotsb
    \end{aligned}$
\end{enumerate}
So $P$ has a $\beta$-normal form $b$, but it also has an infinite reduction.
\end{enumerate}
\end{example}



% \[ (\doublelambda x . x^2 + 3) 2 \bred 2^2 + 3 \]

% \[ \mathbf{Y} := \lambda f . \big( \lambda x . f (xx) \big) \big( \lambda x . f (xx) \big) \]

% ===== NOTES

% This expression $\lambda x . xx$ is normally called the $\mathbf{M}$ combinator. In \citeauthor*{smullyan-1985-to-mock-a-mockingbird}'s language of birds~\parencite[p.~244]{smullyan-1985-to-mock-a-mockingbird}, this is the mockingbird since it applies its argument to itself, effectively `mocking' the argument~\parencite[p.~73]{smullyan-1985-to-mock-a-mockingbird}.
% If we apply $\mathbf{M}$ to itself, we have a problem $\beta$-reducing it: \[ \mathbf{MM} \bred \mathbf{MM} \bred \mathbf{MM} \bred \dotsb \]
% Clearly we can continue this indefinitely, so $\mathbf{MM}$ has no $\beta$-nf.

% See https://cruzgodar.com/applets/lambda-calculus/
% This is iterative Fibonacci for some number k:
% \[ \lambda n . n \big( \lambda g a b . g (+ a b) a \big) (\lambda a b . b) \overline 1 \, \overline 0 \]
% And expanded:
% \[ \lambda n . n \bigg( \lambda g a b . g \Big( \big( \lambda a b f x . (af) (bfx) \big) ab \Big) a \bigg) (\lambda a b . b) (\lambda f x . fx) (\lambda f x . x) \]

\newpage
\nocite{*} % TODO: Trim bib file before submitting
\printbibliography[]

\end{document}
