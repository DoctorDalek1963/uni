% vim: set foldmethod=marker foldlevel=0:

% TODO: Before submitting:
% - Fully anonymise essay
% - Should be approximately 10-12 pages of content (not including contents,
%   bibliography, etc.)
% - Maximum of 15 pages
% - Remove unneeded packages from preamble

\documentclass[a4paper, 11pt]{article}
\usepackage[UKenglish]{babel}

\usepackage{amsmath, amssymb, amsgen}
\usepackage{gensymb}
\usepackage{mathtools}
\usepackage{csquotes}
\usepackage{cancel}

\usepackage{tikz}
\usetikzlibrary{calc}

\usepackage{amsthm}
\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lemma}[thm]{Lemma}
\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newtheorem{example}{Example}[section]
\theoremstyle{remark}
\newtheorem{remark}{Remark}
\newtheorem{case}{Case}

\usepackage[shortlabels]{enumitem}
% \setlist[enumerate]{topsep=0pt}
% \setlist[itemize]{topsep=0pt}

\usepackage[
    backend=biber,
    % citestyle=,
    % bibstyle=,
    style=alphabetic,
    sorting=nty,
    % maxbibnames=5,
]{biblatex}
\addbibresource{main.bib}

\renewcommand\multicitedelim{\addsemicolon\space}

% Name-related code used to display initials instead of middle names in
% bibliography, while maintaining maximum specificity in .bib file
% Taken from https://tex.stackexchange.com/a/188350
\renewcommand*{\mkbibnamegiven}[1]{\edef\firstname{#1}\expandafter\first{\firstname}}

\def\bibnamedelima{ }%
\def\bibnamedelimb{ }%

\makeatletter
\def\@empty{}
\def\first#1{\expandafter\@first#1 \@nil}
\def\@first#1 #2\@nil{#1\addspace%
    \if\relax\detokenize{#2}\relax\else\@initials#2\@nil\fi}
\def\initials#1{\expandafter\@initials#1 \@nil}
\def\@initials#1 #2\@nil{%
    \initial{#1}%
    \def\NextName{#2}%
    \ifx\@empty\NextName\relax%
    \else\bibinitdelim\@initials#2\@nil\fi}
\def\initial#1{\expandafter\@initial#1\@nil}
\def\@initial#1#2\@nil{#1\bibinitperiod}
\makeatother

\usepackage[hidelinks]{hyperref}

\usepackage{minted}
\setminted{
	linenos,
	breaklines,
	fontsize=\footnotesize,
	encoding=utf8,
	style=catppuccin-latte, % Style provided by https://github.com/catppuccin/python
}

\usepackage[quiet]{fontspec}
\setmonofont[Scale=MatchLowercase]{Hack}

\usepackage{fancyhdr}
\pagestyle{fancy}
% TODO: Decide what to do with these
\fancyhead[L]{}
\fancyhead[C]{}
\fancyhead[R]{}

% \usepackage{graphicx}
% \graphicspath{ {./imgs/} }

\newcommand\acong{\equiv_\alpha}
\newcommand\bcon{\mathrel{\rightarrow_\beta}}
\newcommand\bred{\mathrel{\twoheadrightarrow_\beta}}
\newcommand\pred{\mathrel{\twoheadrightarrow_\parallel}}
\newcommand\FV{\operatorname{FV}}
\newcommand\doublelambda{\lambda\mkern-7.5mu\lambda}

% TODO: Declare some reduction relations like $\triangleright_\beta$ with \mathrel or similar to get consistent spacing

\title{\vspace*{-5em} Numbers in the Lambda-Calculus}
\author{}
\date{}

\begin{document}

\maketitle

% \setlength{\parindent}{0em}
% \setlength{\parskip}{1em}

% \pagenumbering{roman}
% \tableofcontents
% \newpage
% \pagenumbering{arabic}

% Plan {{{

% \section{Introduction}

% Recall set theoretic definition of natural numbers so we can draw parallels to them later, and to establish theme of abstract, fundamental definitions. Define the syntax of the lambda calculus, possibly with examples like $\overline \lambda x . x + 3$ but being careful not to conflate the standard lambda syntax\footnote{It is easy to give an example like the one above with the bare $\lambda$, but this can create confusion later when the rules become strict and readers might wonder why we were allowed addition and natural numbers previously.}.

% Motivation using Dana Scott's $D_\infty$~\parencites[\S16]{hindley-seldin-2008-lambda-calculus-and-combinators}[\S\S18--20]{barendregt-1981-lambda-calculus}.

% \section{Abstraction and application}

% Discuss the notions of abstraction and application. It is likely necessary to talk about free and bound variables and discuss the basics of well-formed formulas. Give examples. Also talk about currying conceptually as well as a syntactic shorthand. Possibly include humorous aside from Hindley about `sch\"onfinkeling'~\parencite[p.~3]{hindley-seldin-2008-lambda-calculus-and-combinators}.

% \section{Reduction and conversion}

% Discuss $\alpha$ and $\beta$ reduction. Possibly also $\eta$ reduction. Also mention the Church--Rosser theorem~\parencite[p.~14]{hindley-seldin-2008-lambda-calculus-and-combinators}, which says that two terms are convertible if both reduce to a common term. I don't think it would be feasible to prove this theorem~\parencite[pp.~282--289]{hindley-seldin-2008-lambda-calculus-and-combinators}, but it would be good to mention. % chktex 8

% \subsection{Ideas}

% We need to define the syntax and semantics. We should talk about currying and its $\lambda x y . \cdots$ shorthand. We should define Church numerals, addition, subtraction (how?), and multiplication (does this need recursion?). Maybe conclude with a method to generate the $n$th Fibonacci number. A function would require introducing recursion, which is too much to fit in one essay.

% \section{Numbers}

% This is the climax of the essay. Define Church numerals~\parencites[p.~347]{church-1936-unsolvable-problem-number-theory}[p.~28]{church-1941-calculi-lambda-conversion}[p.~136]{barendregt-1981-lambda-calculus} and their successor function. Possibly also their predecessor function if it's not too complicated (but I suspect it is). Define the first few Fibonacci numbers and point out the pattern for generating more.

% Alternatively, use the Church--Rosser Theorem to prove that addition of Church numerals commutes. % chktex 8

% \section{Further reading}

% Mention recursive functions, fixed-point combinators, Curry's paradoxical combinator~\parencite[\S6.1]{barendregt-1981-lambda-calculus} (often called the Y~combinator), and allude to a recursive definition of the Fibonacci numbers. Also mention \citetitle{turing-1937-computability-and-lambda-definability}, which shows that the $\lambda$-calculus is equivalent to a Turing machine. Also mention efforts to formalise mathematics in the language of $\lambda$-calculus and combinatory logic, \`a~la Zermelo--Fraenkel set theory. % chktex 8

% }}}

% Introduction {{{

\section{Introduction}\label{sec:introduction}

The Zermelo--Fraenkel system of axioms formalises the foundations of mathematics using the language of sets. It is natural to ask which other languages we could use. What about functions? The Zermelo--Fraenkel system defines functions as sets of ordered pairs~\parencite[\S\S2.1--2.2]{ciesielski-1997-set-theory} but we can't do that in a system where we don't have sets, so we need a more broad definition of functions. % chktex 8

% TODO: Talk about history

We want a purely functional universe---that is, a system in which everything is a `pure' function. A pure function, in this case, takes one pure function as input and returns one pure function. So in this world, it's functions all the way down.

In this essay, we will study Alonzo Church's lambda calculus.

% }}}

% Syntax {{{

\section{Syntax}\label{sec:syntax}

In this new lambda calculus, we care primarily about functions, but the common way of writing functions becomes cumbersome for higher-order functions (functions from functions to functions).

% TODO: Is $S$ actually an operator?
% Properly explain this idea of only having functions? Maybe put this in the history section?
% Why exactly can't we do it in ZFC? Can we do it in ZFC?

Let's say we want to define a function $S$ which takes three functions $x, y, z$ as input, and returns the function $(x(z)) (y(z))$. Take a moment to parse that: $x, y, z$ are all functions; $x(z)$ is a function, call it $f$; $y(z)$ is a function, call it $g$, and then $S$ is $f(g)$, another function\footnote{We could write this with composition as $(x \circ z) \circ (y \circ z)$ but we want to stick the $\lambda$-calculus style notation for consistency.}.

This is called the $\mathbf{S}$ combinator and we will see its uses later.

To describe $S$ in full generality in the ZFC system is actually impossible because we need to define a domain. We could say \[
S : F \times F \times F \to F, \qquad (x, y, z) \mapsto (x(z)) (y(z))
\] where $F$ denotes some space of functions $F \to F$. This recursive definition of $F$ is not allowed in ZFC\@. % TODO: Citation needed

In the lambda calculus, we write this simply as \[
\lambda x y z . xz(yz)
\]

More formally, $\lambda$-calculus consists of $\lambda$-terms, defined in the following recursive way \parencite[p.~3]{hindley-seldin-2008-lambda-calculus-and-combinators}:
\begin{enumerate}[(1)]
\item All variables (labelled $a, b, \dotsc, z, a_1, b_1, \dotsc$) are $\lambda$-terms, called \textit{atoms}.
\item If $M$ and $N$ are any two $\lambda$-terms then $(MN)$ is a $\lambda$-term. This is called \textit{application}.
\item If $M$ is any $\lambda$-term and $x$ is any variable then $(\lambda x . M)$ is a $\lambda$-term. This is called \textit{abstraction}.
\end{enumerate}

The reason that Church choose the symbol $\lambda$ has been lost to time. It is either derived from the notation $\hat x$ used by Whitehead and Russell, which became $\wedge x$ and then $\lambda x$ for ease of printing, or the symbol was chosen basically at random \parencite[p.~6]{cardone-hindley-2006-history-of-lambda-calculus}.

\begin{defn}[Scope]\label{def:scope}
In a $\lambda$-term $\lambda x . M$, the occurrence of $M$ is called the \textit{scope} of the occurrence of $\lambda x$.
\end{defn}

\begin{example}[Scope]\label{ex:scope}
\end{example}

\begin{defn}[Free and bound variables]\label{def:free-and-bound-variables}
Let $M$ be an arbitrary $\lambda$-term. A variable $x$ is \textit{free} in $M$ if $x$ is not in the scope of any $\lambda x$; otherwise, $x$ is \textit{bound} \parencite[p.~24]{barendregt-1981-lambda-calculus}. If we're considering the $x$ immediately proceeding the $\lambda$ (that is, the first $x$ in $\lambda x . x$), it is called \textit{bound and binding} \parencite[p.~6--7]{hindley-seldin-2008-lambda-calculus-and-combinators}.

We define $\FV(M)$ as the set of all free variables in the expression $M$. A $\lambda$-term with no free variables is called \textit{closed}.
\end{defn}

\begin{example}[Free and bound variables]\label{ex:free-and-bound-variables}\leavevmode
\begin{enumerate}[(1)]
\item In $x (\lambda y . xy)$, $x$ occurs free twice and $y$ occurs bound once.

\item In $y (\lambda y . y)$, $y$ occurs free once and bound twice. This is confusing and discouraged in practice, but allowed to keep the definitions simple.
\end{enumerate}
Notice that `$\lambda x$' binds in the same way as `$\forall x$' in familiar predicate logic.
\end{example}

% }}}

% Conversion and reduction {{{

\section{Conversion and reduction}\label{sec:conversion-and-reduction}

Given $\lambda$-terms $M$ and $N$ and a variable $x$, we write $M [x := N]$ to mean a new $\lambda$-term which is $M$ with all occurrences of $x$ replaced with $N$ \parencite[p.~27]{barendregt-1981-lambda-calculus}\footnote{Other notations include `$\left. S_N^{\,x} M \right\vert$' \parencites[p.~9]{church-1941-calculi-lambda-conversion}{church-rosser-1936-some-properties-of-conversion} and `$[N / x] M$' \parencites[p.~7]{hindley-seldin-2008-lambda-calculus-and-combinators}[\S\textbf{2}C2]{curry-feys-1958-combinatory-logic-volume-1}.}. For example, \[ (\lambda x y . z x z) \l[ z := (\lambda a . a) \r] \rightarrow (\lambda x y . (\lambda a . a) x (\lambda a . a)). \]

\begin{defn}[$\alpha$-conversion]\label{def:alpha-conversion}
Let a $\lambda$-term $P$ contain an occurrence of $\lambda x . M$ and let $y \notin \FV(M)$. The act of replacing the $\lambda x . M$ with $\lambda y . M [x := y]$ is called \textit{$\alpha$-conversion}.

If a $\lambda$-term $Q$ can be reached by a finite (possibly empty) sequence of $\alpha$-conversions, we say that \textit{$P$ $\alpha$-converts to $Q$} and write $P \acong Q$ \parencite[p.~9]{hindley-seldin-2008-lambda-calculus-and-combinators}.
\end{defn}

\begin{example}[$\alpha$-conversion]\label{ex:alpha-conversion}\leavevmode
\begin{enumerate}[(1)]
\item $\lambda x . x \acong \lambda y . y$

\item $\lambda x . t \acong \lambda y . t$

\item $\lambda x . y \not\acong \lambda y . y$ because $y \in \FV(y)$. The LHS in this case is the constant function that always returns $y$, and the RHS is the identity function. These are not the same, so it doesn't make sense to call them equivalent in the sense of $\alpha$-conversion.

\item $\lambda a b c . bc (ab) c \big( a(cb) \big) \acong \lambda x y z . yz (xy) z \big( x(zy) \big)$

\item $\lambda g_2 j a_{16} . a_{16} (j g_2) a_{16} \acong \lambda x y z . z (yx) z$
\end{enumerate}
\end{example}

\begin{defn}[$\beta$-contraction]\label{def:beta-contraction}
Any term of the form $(\lambda x . M) N$ is called a \textit{$\beta$-redex} and the corresponding term $M [x := N]$ is called its \textit{contractum}.

If a $\lambda$-term $P$ contains an occurrence of $(\lambda x . M) N$ then we can replace that occurrence by $M [x := N]$. We can call the result $P'$ and then we say that \textit{$P$ $\beta$-contracts to $P'$}, and we write $P \bcon P'$.
\end{defn}

\begin{defn}[$\beta$-reduction]\label{def:beta-reduction}
If a $\lambda$-term $Q$ can be reached by a finite (possibly empty) sequence of $\beta$-contractions, we say that \textit{$P$ $\beta$-reduces to $Q$} and write $P \bred Q$ \parencite[pp.~11--12]{hindley-seldin-2008-lambda-calculus-and-combinators}. Formally, $\bred$ is the \textit{reflexive, transitive closure} of $\bcon$ meaning:
\begin{enumerate}[(1)]
\item $M \bcon N$ implies $M \bred N$;
\item $M \bred M$;
\item if $M \bred N$ and $N \bred L$ then $M \bred L$ \parencite[p.~51]{barendregt-1981-lambda-calculus}.
\end{enumerate}
\end{defn}

\begin{defn}[$\beta$-normal form]\label{def:beta-normal-form}
A $\lambda$-term $Q$ which contains no $\beta$-redexes is said to be in \textit{$\beta$-normal form}, sometimes written \textit{$\beta$-nf}. If $P \bred Q$ then $Q$ is called a \textit{$\beta$-normal form of $P$} \parencites[p.~12]{hindley-seldin-2008-lambda-calculus-and-combinators}[p.~34]{barendregt-1981-lambda-calculus}.
\end{defn}

\begin{example}[$\beta$-contraction]\label{ex:beta-contraction}
Let $N$ be an arbitrary $\lambda$-term.
\begin{enumerate}[(1)]
\item $(\lambda x . x) N \bcon N$

\item $(\lambda x . y) N \bcon y$

\item $(\lambda xy . y) N \bcon \lambda y . y$

\item $\begin{aligned}[t]
\big( \lambda xy . x (\lambda z . xzy) \big) (\lambda ab . baa)
    &\bcon \lambda y . (\lambda ab . baa) (\lambda z . (\lambda ab . baa) zy) \\
    &\bcon \lambda y . (\lambda ab . baa) (\lambda z . (\lambda b . bzz) y) \\
    &\bcon \lambda y . (\lambda ab . baa) (\lambda z . yzz) \\
    &\bcon \lambda y . \big( \lambda b . b (\lambda z . yzz) (\lambda z . yzz) \big) \\
    &\equiv \lambda yb . b (\lambda z . yzz) (\lambda z . yzz)
\end{aligned}$

\item $\begin{aligned}[t]
\big( \lambda xyz . x (z y x) \big) (\lambda ab . b b a)
    &\bcon \lambda yz . (\lambda ab . b b a) \big( z y (\lambda ab . b b a) \big) \\
    &\bcon \lambda yz . \Big( \lambda b . b b \big( z y (\lambda cd . d d c) \big) \Big) \\
    &\equiv \lambda yzb . b b \big( z y (\lambda cd . d d c) \big)
\end{aligned}$

This example uses the $\alpha$-conversion convention to rename $a$ to $c$ and $b$ to $d$ after the second $\beta$-contraction. Without this renaming, we would get confusing (but technically valid) variable bindings: \[
\lambda yzb . b b \big( z y (\lambda ab . b b a) \big)
\] In this case, the $b$ inside the innermost brackets is completely unrelated to the $b$ outside, so giving them different names makes the expression easier to understand.

\item\label{ex:beta-reduction:Omega} $\begin{aligned}[t]
(\lambda x . xx) (\lambda x . xx)
    &\bcon (\lambda x . xx) (\lambda x . xx) \\
    &\bcon (\lambda x . xx) (\lambda x . xx) \\
    &\bcon \dotsb
\end{aligned}$

This example shows that the $\beta$-contraction process doesn't always simplify. This term is called $\Omega$ or $\mathbf{M}$. Since $\Omega$ contains $\beta$-redexes and $\Omega \bcon \Omega$, we see that $\Omega$ is an example of a $\lambda$-term with no $\beta$-normal form. But $\Omega$ is `minimal' in the sense that it cannot be reduced to any different term \parencite[p.~13]{hindley-seldin-2008-lambda-calculus-and-combinators}.

\item $\begin{aligned}[t]
(\lambda x . xxy) (\lambda x . xxy)
    &\bcon (\lambda x . xxy) (\lambda x . xxy) y \\
    &\bcon (\lambda x . xxy) (\lambda x . xxy) yy \\
    &\bcon \dotsb
\end{aligned}$

In this example, the $\beta$-contraction process actually makes the expression more `complicated' (in the sense of containing more terms). The initial term $(\lambda x . xxy) (\lambda x . xxy)$ is called $\mathbf{L}$, and it has no $\beta$-normal form.

\item Let $P \equiv (\lambda a . b) \mathbf{L}$. Then $P$ can be reduced in multiple ways, by $\beta$-contracting either $(\lambda a . b)$ or $\mathbf{L}$:
\begin{enumerate}[(i)]
    \item $\begin{aligned}[t]
    P &\equiv (\lambda a . b) \mathbf{L} \\
        &\bcon b [a := \mathbf{L}] \\
        &\equiv b
    \end{aligned}$

    \item $\begin{aligned}[t]
    P &\equiv (\lambda a . b) \mathbf{L} \\
        &\bcon (\lambda a . b) \mathbf{L} y \\
        &\bcon (\lambda a . b) \mathbf{L} yy \\
        &\bcon \dotsb
    \end{aligned}$
\end{enumerate}
So $P$ has a $\beta$-normal form $b$, but it also has an infinite reduction.
\end{enumerate}

It is important to note that all of the $\bcon$ in these examples could've been written with $\bred$. Note that
% $\beta$-reduction is not a process that drives $\beta$-contraction to termination.
$P \bred Q$ does not imply that $Q$ is a $\beta$-nf, nor even that $Q \not\equiv P$, as seen in the case of $\Omega \bred \Omega$.
\end{example}

% }}}

% The Church--Rosser Theorem {{{

\section{Confluence}

Confluence, generally, is a property of rewriting systems in which the order of reductions is unimportant. For example, in normal arithmetic, we could evaluate the expression $(2 + 3) \times (5 + 1)$ by simplifying the left parenthetical and then the right, or right and then left. Either way, we get the same answer.

We want lambda calculus to be confluent because we don't want one term able to produce different results.

\begin{thm}[The Church--Rosser Theorem for $\beta$-reduction]\label{thm:church-rosser-beta-reduction} % chktex 8
If $P \bred M$ and $P \bred N$, then $\exists T$ such that $M \bred T$ and $N \bred R$. See Figure~\ref{fig:church-rosser-diamond}.
\end{thm}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}
    \node[label=above:$P$] (P) at (0, 1.5) {};
    \node[label=left:$M$] (M) at (-1.5, 0) {};
    \node[label=right:$N$] (N) at (1.5, 0) {};
    \node[label=below:$\exists T$] (T) at (0, -1.5) {};

    \fill (P) circle[radius=0.12];
    \fill (M) circle[radius=0.12];
    \fill (N) circle[radius=0.12];
    \draw (T) circle[radius=0.12];

    \begin{scope}[
        ultra thick,
        ->>,
        > = stealth,
        shorten <= 4,
        shorten >= 4
    ]
        \draw (P) -- (M);
        \draw (P) -- (N);
        \draw[loosely dashed] (M) -- (T);
        \draw[loosely dashed] (N) -- (T);
    \end{scope}
\end{tikzpicture}
\caption{The `diamond property' of confluence.}%
\label{fig:church-rosser-diamond}
\end{figure}

This was first proved by \citeauthor{church-rosser-1936-some-properties-of-conversion} in \citeyear{church-rosser-1936-some-properties-of-conversion} \parencite{church-rosser-1936-some-properties-of-conversion} but the proof we will use is attributed to William Tait and Per Martin-L\"of \parencites[pp.~59--62]{barendregt-1981-lambda-calculus}[\S{}A2A]{hindley-seldin-2008-lambda-calculus-and-combinators}\footnote{Apparently this proof was adapted by Martin-L\"of in 1981 from an earlier unpublished proof by Tait for weak reduction \parencite[p.~313]{hindley-seldin-1986-introduction-to-combinators-and-lambda-calculus}, but I can't find an original source from Martin-L\"of.}.

\begin{figure}[htbp]
\centering
%
\begin{minipage}{0.45\linewidth}
\begin{tikzpicture}
    \node[label=above:$P$] (P) at (0, 1) {};

    \node[label=left:$M$] (M) at (-1, 0) {};

    \node[label=right:$N_1$] (N1) at (1, 0) {};
    \node[label=right:$N_2$] (N2) at (2, -1) {};
    \node[label=right:$N$] (N) at (4, -3) {};

    \node[label=below left:$\exists T'$] (T') at (0, -1) {};
    \node[label=below left:$\exists T''$] (T'') at (1, -2) {};
    \node[label=below left:$\exists T$] (T) at (3, -4) {};

    \fill (P) circle[radius=0.12];
    \fill (M) circle[radius=0.12];

    \fill (N1) circle[radius=0.12];
    \fill (N2) circle[radius=0.12];
    \fill (N) circle[radius=0.12];

    \draw (T') circle[radius=0.12];
    \draw (T'') circle[radius=0.12];
    \draw (T) circle[radius=0.12];

    \begin{scope}[
        very thick,
        ->,
        > = stealth,
        shorten <= 3,
        shorten >= 3
    ]
        \draw (P) -- (M);
        \draw (P) -- (N1);
        \draw (N1) -- (N2);
        \draw (N2) -- (N);

        \draw[loosely dashed] (M) -- (T');
        \draw[loosely dashed] (T') -- (T'');
        \draw[loosely dashed] (T'') -- (T);
        \draw[loosely dashed] (N1) -- (T');
        \draw[loosely dashed] (N2) -- (T'');
        \draw[loosely dashed] (N) -- (T);

        \draw[dashed, shorten <= 8, shorten >= 8] ($(N2) + (0.5, -0.5)$) -- ($(T'') + (0.5, -0.5)$);
        \draw[dashed, shorten <= 12, shorten >= 12] ($(N2) + (1, -1)$) -- ($(T'') + (1, -1)$);
        \draw[dashed, shorten <= 16, shorten >= 16] ($(N2) + (1.5, -1.5)$) -- ($(T'') + (1.5, -1.5)$);
    \end{scope}

    \draw[very thick, loosely dotted, shorten <= 25, shorten >= 5] ($(N2) + (0.3, 0.3)$) -- ($(N) + (0.3, 0.3)$);
    \draw[very thick, loosely dotted, shorten <= 10, shorten >= 15] ($(T'') + (-0.5, -0.5)$) -- ($(T) + (-0.5, -0.5)$);
\end{tikzpicture}
\end{minipage}
%
\hfill\begin{minipage}{0.45\linewidth}
\begin{tikzpicture}
    \node[label=above:$P$] (P) at (0, 2) {};

    \node[label=left:$M$] (M) at (-2, 0) {};
    \node[label=above left:$M_1$] (M1) at (-0.6, 1.4) {};

    \node[label=right:$N$] (N) at (2, 0) {};

    \node[label=below right:$\exists T_1$] (T1) at (1.4, -0.6) {};
    \node[label=below:$\exists T$] (T) at (0, -2) {};

    \fill (P) circle[radius=0.12];
    \fill (M) circle[radius=0.12];
    \fill (M1) circle[radius=0.12];
    \fill (N) circle[radius=0.12];
    \draw (T) circle[radius=0.12];

    \fill ($(P) + (0.6, -0.6)$) circle[radius=0.1];
    \fill ($(P) + (1, -1)$) circle[radius=0.1];
    \fill ($(P) + (1.4, -1.4)$) circle[radius=0.1];

    \begin{scope}[
        very thick,
        ->,
        > = stealth,
        shorten <= 4,
        shorten >= 4
    ]
        \draw (P) -- (M);
        \draw (P) -- (N);
        \draw[loosely dashed] (M) -- (T);
        \draw[loosely dashed] (N) -- (T);

        \draw[loosely dashed] (M1) -- (T1);

        \draw[dashed, shorten <= 14, shorten >= 14] ($(M1) + (-0.45, -0.45)$) -- ($(T1) + (-0.45, -0.45)$);
        \draw[dashed, shorten <= 20, shorten >= 20] ($(M1) + (-0.9, -0.9)$) -- ($(T1) + (-0.9, -0.9)$);
    \end{scope}

    % Needs to be on top of dashed line
    \draw[fill=white] (T1) circle[radius=0.12];

    \draw[very thick, loosely dotted, shorten <= 15, shorten >= 5] ($(M1) + (-0.3, 0.3)$) -- ($(M) + (-0.3, 0.3)$);
    \draw[very thick, loosely dotted, shorten <= 10, shorten >= 5] ($(T1) + (0.3, -0.3)$) -- ($(T) + (0.3, -0.3)$);
\end{tikzpicture}
\end{minipage}
%
\caption{The desired diagram chase\protect\footnotemark.}%
\label{fig:beta-contraction-diagram-chasing}
\end{figure}
\footnotetext{Reproduced from Fig.~A2:2 in \parencite[p.~283]{hindley-seldin-2008-lambda-calculus-and-combinators}.}

Ideally, we want break this down into a series of $\beta$-contractions and do some diagram chasing, as seen in Figure~\ref{fig:beta-contraction-diagram-chasing}. If we could prove that $\beta$-contraction is confluent, that is \[ P \bcon M \text{ and } P \bcon N \implies \exists T \text{ such that } M \bcon T \text{ and } N \bcon T, \] then we could chain steps of single $\beta$-contractions together. We would first prove Theorem~\ref{thm:church-rosser-beta-reduction} in the special case that $P \bcon M$ by induction on the length of the reduction to $N$, as seen on the left of Figure~\ref{fig:beta-contraction-diagram-chasing}. Then we could deduce that general case by induction on the length of the reduction to $M$, as seen on the right side of the diagram.

The problem is that this doesn't work. Consider for example ${P := (\lambda y . uyy) (\mathbf{I} z)}$ where $\mathbf{I} = \lambda x . x$. Then ${P \bcon u (\mathbf{I} z) (\mathbf{I} z)}$ and $P \bcon {(\lambda y . uyy) z} \bcon uzz$. In this case we have ${M := u (\mathbf{I} z) (\mathbf{I} z)}$ but $M$ cannot be reduced to $uzz$ in just one contraction. It can, however, be reduced using two non-overlapping, `parallel' contractions. It turns out that we can define a new relation $\pred$ (parallel reduction) whose transitive closure is the same as that of $\bred$. Then if $\pred$ satisfies the diamond property, then so does $\bred$ and we have proven the Church--Rosser Theorem. % chktex 8

Unfortunately, the obvious definition of $\pred$ as simultaneous non-overlapping contractions doesn't work, but we can define parallel reduction in a more subtle way. % chktex 8

\begin{defn}[Residuals]
Let a $\lambda$-term $P$ contain $\beta$-redexes $R$ and $S$. Let $P'$ be the result of $\beta$-contracting $R$ in $P$, so $P \bcon P'$. The \textit{residuals} of $S$ with respect to $R$ are $\beta$-redexes in $P'$, defined as follows:
%
\begin{case}
$R$ and $S$ are non-overlapping parts of $P$. Then $\beta$-contracting $R$ leaves $S$ unchanged. We call the unchanged $S$ in $P'$ the residual of $S$.
\end{case}
%
\begin{case}
\end{case}
%
\begin{case}
\end{case}
%
\begin{case}
% TODO: Define `proper part'
$S$ is a proper part of $R$. Then $R$ has the form $(\lambda x . M) N$ and $S$ is in $M$ or in $N$. There are other subcases here \parencite[pp.~284--285]{hindley-seldin-2008-lambda-calculus-and-combinators} but case 4 is not needed for our confluence proof, so we shall ignore it from now on.
\end{case}
\end{defn}

\begin{defn}[Minimal residual]
\end{defn}

\begin{defn}[Parallel reduction]
\footnote{Parallel reductions were sometimes called \textit{minimal complete reductions} \parencite[p.~315]{hindley-seldin-1986-introduction-to-combinators-and-lambda-calculus}.}
\end{defn}

% Now we will prove Theorem~\ref{thm:church-rosser-beta-reduction}.
% \begin{proof}
% Trivial.
% \end{proof}

% }}}



% Notes {{{

% \[ (\doublelambda x . x^2 + 3) 2 \bred 2^2 + 3 \]

% \[ \mathbf{Y} := \lambda f . \big( \lambda x . f (xx) \big) \big( \lambda x . f (xx) \big) \]

% This expression $\lambda x . xx$ is normally called the $\mathbf{M}$ combinator. In \citeauthor*{smullyan-1985-to-mock-a-mockingbird}'s language of birds~\parencite[p.~244]{smullyan-1985-to-mock-a-mockingbird}, this is the mockingbird since it applies its argument to itself, effectively `mocking' the argument~\parencite[p.~73]{smullyan-1985-to-mock-a-mockingbird}.
% If we apply $\mathbf{M}$ to itself, we have a problem $\beta$-reducing it: \[ \mathbf{MM} \bred \mathbf{MM} \bred \mathbf{MM} \bred \dotsb \]
% Clearly we can continue this indefinitely, so $\mathbf{MM}$ has no $\beta$-nf.

% See https://cruzgodar.com/applets/lambda-calculus/
% This is iterative Fibonacci for some number k:
% \[ \lambda n . n \big( \lambda g a b . g (+ a b) a \big) (\lambda a b . b) \overline 1 \, \overline 0 \]
% And expanded:
% \[ \lambda n . n \bigg( \lambda g a b . g \Big( \big( \lambda a b f x . (af) (bfx) \big) ab \Big) a \bigg) (\lambda a b . b) (\lambda f x . fx) (\lambda f x . x) \]

% https://theory.stanford.edu/~blynn/lambda/diamond.html

% }}}

\newpage
\nocite{*} % TODO: Trim bib file before submitting
\printbibliography[]

\end{document}
